from __future__ import annotations
# meta programming  

from typing import List, Union

import torch

from indentprinter import IndentPrinter
from torchWork import DEVICE, CPU
from torchWork.loss_weight_tree import LossWeightTree

__all__ = ['LossTree', 'AbstractLossNode', 'writeCode']

class AbstractLossNode:
    def __init__(
        self, name, children: List[Union[AbstractLossNode, str]], 
    ) -> None:
        self.name = name
        self.children = children

        self.class_name = name[0].upper() + name[1:]

class LossTree:
    def __init__(self):
        self.name: str = None
        self.children: List[str] = None
    
    def sum(
        self, lossWeightTree: LossWeightTree, epoch: int, 
    ):
        acc = torch.tensor(0, dtype=torch.float32, device=CPU)
        for lossWeightNode in lossWeightTree.children:
            weight = lossWeightNode.getWeight(epoch)
            if weight == 0:
                # Allow compute-skipped losses to be None
                continue
            child: Union[LossTree, torch.Tensor] = self.__getattribute__(
                lossWeightNode.name, 
            )
            if lossWeightNode.children is None:
                assert isinstance(child, (torch.Tensor, float, int))
                acc += weight * child
            else:
                assert len(lossWeightNode.children)
                assert isinstance(child, LossTree)
                acc += weight * child.sum(
                    lossWeightNode, epoch, 
                )
        return acc
    
    def __add__(self, other: LossTree):
        new = self.__class__()
        for child in self.children:
            new.__setattr__(child, (
                self .__getattribute__(child) + 
                other.__getattribute__(child)
            ))
        return new

    def __div__(self, other: float):
        new = self.__class__()
        for child in self.children:
            new.__setattr__(child, (
                self.__getattribute__(child) / other
            ))
        return new

def writeCode(file, root: AbstractLossNode):
    def p(*a, **kw):
        print(*a, file=file, **kw)
    p('from __future__ import annotations')
    module_name = 'loss_tree' if __name__ == '__main__' else __name__
    p(f'# Auto generated by torchWork.{module_name} .')
    p('# Do not modify!')
    p('# Git ignore this!')
    p()
    p(f'from torchWork import LossTree')
    p()
    dfs(p, root)

def dfs(p, node: AbstractLossNode):
    p(f'class {node.class_name}(LossTree):')
    with IndentPrinter(p) as p:
        for child in node.children:
            if isinstance(child, AbstractLossNode):
                dfs(p, child)
        
        p('def __init__(self):')
        with IndentPrinter(p) as p:
            p('super().__init__()')
            p(f"self.name = '{node.name}'")
            names = []
            for child in node.children:
                if isinstance(child, AbstractLossNode):
                    names.append(child.name)
                    p('self.%s: __class__.%s = __class__.%s()' % (
                        child.name, child.class_name, child.class_name, 
                    ))
                else:
                    names.append(child)
                    p('self.%s: float = None' % child)
            p('self.children = [', end='')
            for name in names:
                p(f"'{name}', ", end='')
            p(']')
    p()
